// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfacePhantomLogger,
} from './phantom_rs-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterBool,
  FfiConverterCallback,
  FfiConverterInt32,
  FfiConverterObject,
  FfiConverterUInt16,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiRustCallAsync,
  uniffiTraitInterfaceCall,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

export interface PhantomLogger {
  logString(str: string): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePhantomLogger: {
  vtable: UniffiVTableCallbackInterfacePhantomLogger;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    logString: (uniffiHandle: bigint, str: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypePhantomLogger.lift(uniffiHandle);
        return jsCallback.logString(FfiConverterString.lift(str));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // PhantomLogger: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypePhantomLogger.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_phantom_rs_fn_init_callback_vtable_phantomlogger(
      uniffiCallbackInterfacePhantomLogger.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypePhantomLogger = new FfiConverterCallback<PhantomLogger>();

export type PhantomOpts = {
  server: string;
  bind: string;
  bindPort: /*u16*/ number;
  timeout: /*u64*/ bigint;
  debug: boolean;
  ipv6: boolean;
};

/**
 * Generated factory for {@link PhantomOpts} record objects.
 */
export const PhantomOpts = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PhantomOpts, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PhantomOpts}, with defaults specified
     * in Rust, in the {@link phantom_rs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PhantomOpts}, with defaults specified
     * in Rust, in the {@link phantom_rs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link phantom_rs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PhantomOpts>,
  });
})();

const FfiConverterTypePhantomOpts = (() => {
  type TypeName = PhantomOpts;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        server: FfiConverterString.read(from),
        bind: FfiConverterString.read(from),
        bindPort: FfiConverterUInt16.read(from),
        timeout: FfiConverterUInt64.read(from),
        debug: FfiConverterBool.read(from),
        ipv6: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.server, into);
      FfiConverterString.write(value.bind, into);
      FfiConverterUInt16.write(value.bindPort, into);
      FfiConverterUInt64.write(value.timeout, into);
      FfiConverterBool.write(value.debug, into);
      FfiConverterBool.write(value.ipv6, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.server) +
        FfiConverterString.allocationSize(value.bind) +
        FfiConverterUInt16.allocationSize(value.bindPort) +
        FfiConverterUInt64.allocationSize(value.timeout) +
        FfiConverterBool.allocationSize(value.debug) +
        FfiConverterBool.allocationSize(value.ipv6)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: PhantomError

// Enum: PhantomError
export enum PhantomError_Tags {
  UnknownError = 'UnknownError',
  FailedToBind = 'FailedToBind',
  FailedToStart = 'FailedToStart',
  IoError = 'IoError',
  InvalidAddress = 'InvalidAddress',
  AlreadyRunning = 'AlreadyRunning',
  LoggerSetupFailed = 'LoggerSetupFailed',
}
export const PhantomError = (() => {
  type UnknownError__interface = {
    tag: PhantomError_Tags.UnknownError;
    inner: Readonly<[string]>;
  };

  class UnknownError_ extends UniffiError implements UnknownError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PhantomError';
    readonly tag = PhantomError_Tags.UnknownError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PhantomError', 'UnknownError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): UnknownError_ {
      return new UnknownError_(v0);
    }

    static instanceOf(obj: any): obj is UnknownError_ {
      return obj.tag === PhantomError_Tags.UnknownError;
    }

    static hasInner(obj: any): obj is UnknownError_ {
      return UnknownError_.instanceOf(obj);
    }

    static getInner(obj: UnknownError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type FailedToBind__interface = {
    tag: PhantomError_Tags.FailedToBind;
    inner: Readonly<[string]>;
  };

  class FailedToBind_ extends UniffiError implements FailedToBind__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PhantomError';
    readonly tag = PhantomError_Tags.FailedToBind;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PhantomError', 'FailedToBind');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): FailedToBind_ {
      return new FailedToBind_(v0);
    }

    static instanceOf(obj: any): obj is FailedToBind_ {
      return obj.tag === PhantomError_Tags.FailedToBind;
    }

    static hasInner(obj: any): obj is FailedToBind_ {
      return FailedToBind_.instanceOf(obj);
    }

    static getInner(obj: FailedToBind_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type FailedToStart__interface = {
    tag: PhantomError_Tags.FailedToStart;
    inner: Readonly<[string]>;
  };

  class FailedToStart_ extends UniffiError implements FailedToStart__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PhantomError';
    readonly tag = PhantomError_Tags.FailedToStart;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PhantomError', 'FailedToStart');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): FailedToStart_ {
      return new FailedToStart_(v0);
    }

    static instanceOf(obj: any): obj is FailedToStart_ {
      return obj.tag === PhantomError_Tags.FailedToStart;
    }

    static hasInner(obj: any): obj is FailedToStart_ {
      return FailedToStart_.instanceOf(obj);
    }

    static getInner(obj: FailedToStart_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type IoError__interface = {
    tag: PhantomError_Tags.IoError;
    inner: Readonly<[string]>;
  };

  class IoError_ extends UniffiError implements IoError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PhantomError';
    readonly tag = PhantomError_Tags.IoError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PhantomError', 'IoError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): IoError_ {
      return new IoError_(v0);
    }

    static instanceOf(obj: any): obj is IoError_ {
      return obj.tag === PhantomError_Tags.IoError;
    }

    static hasInner(obj: any): obj is IoError_ {
      return IoError_.instanceOf(obj);
    }

    static getInner(obj: IoError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidAddress__interface = {
    tag: PhantomError_Tags.InvalidAddress;
    inner: Readonly<[string]>;
  };

  class InvalidAddress_
    extends UniffiError
    implements InvalidAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PhantomError';
    readonly tag = PhantomError_Tags.InvalidAddress;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PhantomError', 'InvalidAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidAddress_ {
      return new InvalidAddress_(v0);
    }

    static instanceOf(obj: any): obj is InvalidAddress_ {
      return obj.tag === PhantomError_Tags.InvalidAddress;
    }

    static hasInner(obj: any): obj is InvalidAddress_ {
      return InvalidAddress_.instanceOf(obj);
    }

    static getInner(obj: InvalidAddress_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type AlreadyRunning__interface = {
    tag: PhantomError_Tags.AlreadyRunning;
  };

  class AlreadyRunning_
    extends UniffiError
    implements AlreadyRunning__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PhantomError';
    readonly tag = PhantomError_Tags.AlreadyRunning;
    constructor() {
      super('PhantomError', 'AlreadyRunning');
    }

    static new(): AlreadyRunning_ {
      return new AlreadyRunning_();
    }

    static instanceOf(obj: any): obj is AlreadyRunning_ {
      return obj.tag === PhantomError_Tags.AlreadyRunning;
    }

    static hasInner(obj: any): obj is AlreadyRunning_ {
      return false;
    }
  }

  type LoggerSetupFailed__interface = {
    tag: PhantomError_Tags.LoggerSetupFailed;
    inner: Readonly<[string]>;
  };

  class LoggerSetupFailed_
    extends UniffiError
    implements LoggerSetupFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PhantomError';
    readonly tag = PhantomError_Tags.LoggerSetupFailed;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PhantomError', 'LoggerSetupFailed');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): LoggerSetupFailed_ {
      return new LoggerSetupFailed_(v0);
    }

    static instanceOf(obj: any): obj is LoggerSetupFailed_ {
      return obj.tag === PhantomError_Tags.LoggerSetupFailed;
    }

    static hasInner(obj: any): obj is LoggerSetupFailed_ {
      return LoggerSetupFailed_.instanceOf(obj);
    }

    static getInner(obj: LoggerSetupFailed_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is PhantomError {
    return obj[uniffiTypeNameSymbol] === 'PhantomError';
  }

  return Object.freeze({
    instanceOf,
    UnknownError: UnknownError_,
    FailedToBind: FailedToBind_,
    FailedToStart: FailedToStart_,
    IoError: IoError_,
    InvalidAddress: InvalidAddress_,
    AlreadyRunning: AlreadyRunning_,
    LoggerSetupFailed: LoggerSetupFailed_,
  });
})();

export type PhantomError = InstanceType<
  (typeof PhantomError)[keyof Omit<typeof PhantomError, 'instanceOf'>]
>;

// FfiConverter for enum PhantomError
const FfiConverterTypePhantomError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PhantomError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PhantomError.UnknownError(FfiConverterString.read(from));
        case 2:
          return new PhantomError.FailedToBind(FfiConverterString.read(from));
        case 3:
          return new PhantomError.FailedToStart(FfiConverterString.read(from));
        case 4:
          return new PhantomError.IoError(FfiConverterString.read(from));
        case 5:
          return new PhantomError.InvalidAddress(FfiConverterString.read(from));
        case 6:
          return new PhantomError.AlreadyRunning();
        case 7:
          return new PhantomError.LoggerSetupFailed(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PhantomError_Tags.UnknownError: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case PhantomError_Tags.FailedToBind: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case PhantomError_Tags.FailedToStart: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case PhantomError_Tags.IoError: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case PhantomError_Tags.InvalidAddress: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case PhantomError_Tags.AlreadyRunning: {
          ordinalConverter.write(6, into);
          return;
        }
        case PhantomError_Tags.LoggerSetupFailed: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that PhantomError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PhantomError_Tags.UnknownError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case PhantomError_Tags.FailedToBind: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case PhantomError_Tags.FailedToStart: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case PhantomError_Tags.IoError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case PhantomError_Tags.InvalidAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case PhantomError_Tags.AlreadyRunning: {
          return ordinalConverter.allocationSize(6);
        }
        case PhantomError_Tags.LoggerSetupFailed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface PhantomInterface {
  setLogger(logger: PhantomLogger) /*throws*/ : void;
  start(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  stop(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

export class Phantom extends UniffiAbstractObject implements PhantomInterface {
  readonly [uniffiTypeNameSymbol] = 'Phantom';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(opts: PhantomOpts) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypePhantomError.lift.bind(
        FfiConverterTypePhantomError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_phantom_rs_fn_constructor_phantom_new(
          FfiConverterTypePhantomOpts.lower(opts),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypePhantomObjectFactory.bless(pointer);
  }

  public setLogger(logger: PhantomLogger): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypePhantomError.lift.bind(
        FfiConverterTypePhantomError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_phantom_rs_fn_method_phantom_set_logger(
          uniffiTypePhantomObjectFactory.clonePointer(this),
          FfiConverterTypePhantomLogger.lower(logger),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public async start(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_phantom_rs_fn_method_phantom_start(
            uniffiTypePhantomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_phantom_rs_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_phantom_rs_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_phantom_rs_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_phantom_rs_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypePhantomError.lift.bind(
          FfiConverterTypePhantomError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async stop(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_phantom_rs_fn_method_phantom_stop(
            uniffiTypePhantomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_phantom_rs_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_phantom_rs_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_phantom_rs_rust_future_complete_void,
        /*freeFunc:*/ nativeModule().ubrn_ffi_phantom_rs_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypePhantomError.lift.bind(
          FfiConverterTypePhantomError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypePhantomObjectFactory.pointer(this);
      uniffiTypePhantomObjectFactory.freePointer(pointer);
      uniffiTypePhantomObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Phantom {
    return uniffiTypePhantomObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypePhantomObjectFactory: UniffiObjectFactory<PhantomInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): PhantomInterface {
        const instance = Object.create(Phantom.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'Phantom';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_phantom_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: PhantomInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: PhantomInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_phantom_rs_fn_clone_phantom(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_phantom_rs_fn_free_phantom(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is PhantomInterface {
        return (
          obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Phantom'
        );
      },
    };
  })();
// FfiConverter for PhantomInterface
const FfiConverterTypePhantom = new FfiConverterObject(
  uniffiTypePhantomObjectFactory
);

export interface ProxyInstanceInterface {}

export class ProxyInstance
  extends UniffiAbstractObject
  implements ProxyInstanceInterface
{
  readonly [uniffiTypeNameSymbol] = 'ProxyInstance';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeProxyInstanceObjectFactory.bless(pointer);
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeProxyInstanceObjectFactory.pointer(this);
      uniffiTypeProxyInstanceObjectFactory.freePointer(pointer);
      uniffiTypeProxyInstanceObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ProxyInstance {
    return uniffiTypeProxyInstanceObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeProxyInstanceObjectFactory: UniffiObjectFactory<ProxyInstanceInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): ProxyInstanceInterface {
        const instance = Object.create(ProxyInstance.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'ProxyInstance';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_proxyinstance_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: ProxyInstanceInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: ProxyInstanceInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_phantom_rs_fn_clone_proxyinstance(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_phantom_rs_fn_free_proxyinstance(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is ProxyInstanceInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'ProxyInstance'
        );
      },
    };
  })();
// FfiConverter for ProxyInstanceInterface
const FfiConverterTypeProxyInstance = new FfiConverterObject(
  uniffiTypeProxyInstanceObjectFactory
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_phantom_rs_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_phantom_rs_checksum_method_phantom_set_logger() !==
    30436
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_phantom_rs_checksum_method_phantom_set_logger'
    );
  }
  if (
    nativeModule().ubrn_uniffi_phantom_rs_checksum_method_phantom_start() !==
    65119
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_phantom_rs_checksum_method_phantom_start'
    );
  }
  if (
    nativeModule().ubrn_uniffi_phantom_rs_checksum_method_phantom_stop() !==
    6025
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_phantom_rs_checksum_method_phantom_stop'
    );
  }
  if (
    nativeModule().ubrn_uniffi_phantom_rs_checksum_constructor_phantom_new() !==
    11686
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_phantom_rs_checksum_constructor_phantom_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_phantom_rs_checksum_method_phantomlogger_log_string() !==
    15704
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_phantom_rs_checksum_method_phantomlogger_log_string'
    );
  }

  uniffiCallbackInterfacePhantomLogger.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypePhantom,
    FfiConverterTypePhantomOpts,
    FfiConverterTypeProxyInstance,
  },
});
